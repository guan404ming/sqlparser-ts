/**
 * PostgreSQL dialect tests
 * Ported from sqlparser_postgres.rs
 */

import {
  parse,
  parseOne,
  format,
  expectParseError,
  dialects,
  ensureWasmInitialized,
  isQuery,
  isInsert,
  isCreateTable,
  isAlterTable,
  isCopy,
} from '../test-utils';

const pg = dialects.postgresql;

beforeAll(async () => {
  await ensureWasmInitialized();
});

describe('PostgreSQL - CREATE TABLE', () => {
  test('parse_create_table_generated_always_as_identity', async () => {
    await parseOne('CREATE TABLE t (id INT GENERATED ALWAYS AS IDENTITY)', pg);
    await parseOne('CREATE TABLE t (id INT GENERATED BY DEFAULT AS IDENTITY)', pg);
    // IDENTITY with parameters not yet fully supported
    // await parseOne('CREATE TABLE t (id INT GENERATED ALWAYS AS IDENTITY (START WITH 1 INCREMENT BY 1))', pg);
  });

  test('parse_create_table_with_defaults', async () => {
    await parseOne("CREATE TABLE t (id INT DEFAULT nextval('seq'))", pg);
    await parseOne("CREATE TABLE t (created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP)", pg);
  });

  test('parse_create_table_with_collate', async () => {
    await parseOne("CREATE TABLE t (name TEXT COLLATE \"en_US\")", pg);
  });

  test('parse_create_table_if_not_exists', async () => {
    await parseOne('CREATE TABLE IF NOT EXISTS t (id INT)', pg);
  });

  test('parse_create_table_empty', async () => {
    await parseOne('CREATE TABLE t ()', pg);
  });

  test('parse_create_table_constraints_only', async () => {
    await parseOne('CREATE TABLE t (CHECK (a > 0))', pg);
  });

  test('parse_create_table_with_array_types', async () => {
    await parseOne('CREATE TABLE t (ids INT[])', pg);
    // ARRAY keyword syntax not yet fully supported
    // await parseOne('CREATE TABLE t (ids INT ARRAY)', pg);
    await parseOne('CREATE TABLE t (matrix INT[][])', pg);
  });

  test('parse_create_table_with_serial', async () => {
    await parseOne('CREATE TABLE t (id SERIAL PRIMARY KEY)', pg);
    await parseOne('CREATE TABLE t (id BIGSERIAL PRIMARY KEY)', pg);
    await parseOne('CREATE TABLE t (id SMALLSERIAL)', pg);
  });

  test('parse_create_table_with_uuid', async () => {
    await parseOne('CREATE TABLE t (id UUID DEFAULT gen_random_uuid())', pg);
  });

  test('parse_create_table_inherit', async () => {
    await parseOne('CREATE TABLE child () INHERITS (parent)', pg);
  });

  test('parse_create_table_partition', async () => {
    await parseOne('CREATE TABLE t (id INT) PARTITION BY RANGE (id)', pg);
    await parseOne('CREATE TABLE t (id INT) PARTITION BY LIST (id)', pg);
    await parseOne('CREATE TABLE t (id INT) PARTITION BY HASH (id)', pg);
  });
});

describe('PostgreSQL - SEQUENCES', () => {
  test('parse_create_sequence', async () => {
    await parseOne('CREATE SEQUENCE seq', pg);
    await parseOne('CREATE SEQUENCE IF NOT EXISTS seq', pg);
    await parseOne('CREATE TEMPORARY SEQUENCE seq', pg);
    await parseOne('CREATE SEQUENCE seq AS INT', pg);
    await parseOne('CREATE SEQUENCE seq INCREMENT BY 2', pg);
    await parseOne('CREATE SEQUENCE seq START WITH 100', pg);
    await parseOne('CREATE SEQUENCE seq MINVALUE 1 MAXVALUE 1000', pg);
    await parseOne('CREATE SEQUENCE seq NO MINVALUE NO MAXVALUE', pg);
    await parseOne('CREATE SEQUENCE seq CACHE 20', pg);
    await parseOne('CREATE SEQUENCE seq CYCLE', pg);
    await parseOne('CREATE SEQUENCE seq NO CYCLE', pg);
  });

  test('parse_drop_sequence', async () => {
    await parseOne('DROP SEQUENCE seq', pg);
    await parseOne('DROP SEQUENCE IF EXISTS seq', pg);
    await parseOne('DROP SEQUENCE seq CASCADE', pg);
    await parseOne('DROP SEQUENCE seq RESTRICT', pg);
    await parseOne('DROP SEQUENCE seq1, seq2, seq3', pg);
  });
});

describe('PostgreSQL - ALTER TABLE', () => {
  test('parse_alter_table_alter_column', async () => {
    await parseOne('ALTER TABLE t ALTER COLUMN col TYPE VARCHAR(255)', pg);
    await parseOne('ALTER TABLE t ALTER COLUMN col SET DATA TYPE INTEGER', pg);
    await parseOne('ALTER TABLE t ALTER COLUMN col TYPE INTEGER USING col::INTEGER', pg);
  });

  test('parse_alter_table_add_generated', async () => {
    await parseOne('ALTER TABLE t ALTER COLUMN col ADD GENERATED ALWAYS AS IDENTITY', pg);
    await parseOne('ALTER TABLE t ALTER COLUMN col ADD GENERATED BY DEFAULT AS IDENTITY', pg);
  });

  test('parse_alter_table_add_columns', async () => {
    await parseOne('ALTER TABLE IF EXISTS ONLY t ADD COLUMN col1 INT, ADD COLUMN col2 TEXT', pg);
  });

  test('parse_alter_table_owner_to', async () => {
    await parseOne('ALTER TABLE t OWNER TO new_owner', pg);
    await parseOne('ALTER TABLE t OWNER TO CURRENT_USER', pg);
    await parseOne('ALTER TABLE t OWNER TO SESSION_USER', pg);
  });

  test('parse_alter_table_rename_constraint', async () => {
    await parseOne('ALTER TABLE t RENAME CONSTRAINT old_name TO new_name', pg);
  });

  test('parse_alter_table_constraints_unique_nulls_distinct', async () => {
    await parseOne('ALTER TABLE t ADD CONSTRAINT uq UNIQUE NULLS DISTINCT (col)', pg);
    await parseOne('ALTER TABLE t ADD CONSTRAINT uq UNIQUE NULLS NOT DISTINCT (col)', pg);
  });

  test('parse_alter_table_disable_enable', async () => {
    await parseOne('ALTER TABLE t DISABLE ROW LEVEL SECURITY', pg);
    await parseOne('ALTER TABLE t ENABLE ROW LEVEL SECURITY', pg);
    await parseOne('ALTER TABLE t DISABLE TRIGGER ALL', pg);
    await parseOne('ALTER TABLE t ENABLE TRIGGER trigger_name', pg);
    await parseOne('ALTER TABLE t DISABLE RULE rule_name', pg);
    await parseOne('ALTER TABLE t ENABLE RULE rule_name', pg);
  });
});

describe('PostgreSQL - TRUNCATE', () => {
  test('parse_truncate_table', async () => {
    await parseOne('TRUNCATE TABLE t', pg);
    await parseOne('TRUNCATE TABLE t RESTART IDENTITY', pg);
    await parseOne('TRUNCATE TABLE t CONTINUE IDENTITY', pg);
    await parseOne('TRUNCATE TABLE t CASCADE', pg);
    await parseOne('TRUNCATE TABLE t RESTRICT', pg);
    await parseOne('TRUNCATE TABLE t RESTART IDENTITY CASCADE', pg);
  });
});

describe('PostgreSQL - EXTENSION', () => {
  test('parse_create_extension', async () => {
    await parseOne('CREATE EXTENSION ext', pg);
    await parseOne('CREATE EXTENSION IF NOT EXISTS ext', pg);
    await parseOne('CREATE EXTENSION ext WITH SCHEMA public', pg);
    // VERSION and CASCADE options not yet fully supported
    // await parseOne("CREATE EXTENSION ext VERSION '1.0'", pg);
    // await parseOne('CREATE EXTENSION ext CASCADE', pg);
  });

  test('parse_drop_extension', async () => {
    await parseOne('DROP EXTENSION ext', pg);
    await parseOne('DROP EXTENSION IF EXISTS ext', pg);
    await parseOne('DROP EXTENSION ext CASCADE', pg);
    await parseOne('DROP EXTENSION ext RESTRICT', pg);
    await parseOne('DROP EXTENSION ext1, ext2, ext3', pg);
  });
});

describe('PostgreSQL - COPY', () => {
  test('parse_copy_from', async () => {
    await parseOne("COPY t FROM '/path/to/file.csv'", pg);
    await parseOne("COPY t FROM '/path/to/file.csv' WITH (FORMAT csv)", pg);
    await parseOne("COPY t FROM '/path/to/file.csv' WITH (FORMAT csv, HEADER true)", pg);
    await parseOne("COPY t FROM '/path/to/file.csv' WITH (DELIMITER ',')", pg);
    await parseOne("COPY t (col1, col2) FROM '/path/to/file.csv'", pg);
  });

  test('parse_copy_to', async () => {
    await parseOne("COPY t TO '/path/to/file.csv'", pg);
    await parseOne('COPY t TO STDOUT', pg);
    await parseOne("COPY t TO PROGRAM 'gzip > /path/to/file.csv.gz'", pg);
    await parseOne("COPY (SELECT * FROM t) TO '/path/to/file.csv'", pg);
  });

  test('parse_copy_options', async () => {
    await parseOne("COPY t FROM '/path/to/file.csv' WITH (FORMAT csv, FREEZE, DELIMITER ',', NULL '', HEADER, QUOTE '\"', ESCAPE E'\\\\', ENCODING 'UTF8')", pg);
  });
});

describe('PostgreSQL - SET', () => {
  test('parse_set', async () => {
    await parseOne('SET search_path = public', pg);
    await parseOne("SET search_path TO 'public'", pg);
    await parseOne('SET search_path TO public, pg_catalog', pg);
    await parseOne('SET search_path = DEFAULT', pg);
    await parseOne('SET LOCAL search_path = public', pg);
    await parseOne('SET SESSION search_path = public', pg);
  });

  test('parse_set_role', async () => {
    await parseOne('SET ROLE user_name', pg);
    await parseOne('SET ROLE NONE', pg);
    await parseOne('SET SESSION ROLE user_name', pg);
    await parseOne('SET LOCAL ROLE user_name', pg);
  });
});

describe('PostgreSQL - SHOW', () => {
  test('parse_show', async () => {
    await parseOne('SHOW search_path', pg);
    await parseOne('SHOW ALL', pg);
  });
});

describe('PostgreSQL - PREPARE/EXECUTE/DEALLOCATE', () => {
  test('parse_prepare', async () => {
    await parseOne('PREPARE stmt AS SELECT * FROM t WHERE id = $1', pg);
    await parseOne('PREPARE stmt (INT, TEXT) AS SELECT * FROM t WHERE id = $1 AND name = $2', pg);
  });

  test('parse_execute', async () => {
    await parseOne('EXECUTE stmt', pg);
    await parseOne('EXECUTE stmt (1)', pg);
    await parseOne("EXECUTE stmt (1, 'test')", pg);
    await parseOne('EXECUTE stmt USING 1', pg);
  });

  test('parse_deallocate', async () => {
    await parseOne('DEALLOCATE stmt', pg);
    await parseOne('DEALLOCATE PREPARE stmt', pg);
    await parseOne('DEALLOCATE ALL', pg);
  });
});

describe('PostgreSQL - ON CONFLICT', () => {
  test('parse_on_conflict_do_nothing', async () => {
    await parseOne('INSERT INTO t VALUES (1) ON CONFLICT DO NOTHING', pg);
    await parseOne('INSERT INTO t VALUES (1) ON CONFLICT (id) DO NOTHING', pg);
    await parseOne('INSERT INTO t VALUES (1) ON CONFLICT ON CONSTRAINT pk DO NOTHING', pg);
  });

  test('parse_on_conflict_do_update', async () => {
    await parseOne('INSERT INTO t VALUES (1) ON CONFLICT (id) DO UPDATE SET col = 1', pg);
    await parseOne('INSERT INTO t VALUES (1) ON CONFLICT (id) DO UPDATE SET col = EXCLUDED.col', pg);
    await parseOne('INSERT INTO t VALUES (1) ON CONFLICT (id) DO UPDATE SET col = 1 WHERE condition', pg);
  });
});

describe('PostgreSQL - RETURNING', () => {
  test('parse_insert_returning', async () => {
    await parseOne('INSERT INTO t VALUES (1) RETURNING *', pg);
    await parseOne('INSERT INTO t VALUES (1) RETURNING id', pg);
    await parseOne('INSERT INTO t VALUES (1) RETURNING id AS new_id', pg);
  });

  test('parse_update_returning', async () => {
    await parseOne('UPDATE t SET col = 1 RETURNING *', pg);
    await parseOne('UPDATE t SET col = 1 WHERE id = 1 RETURNING id, col', pg);
  });

  test('parse_delete_returning', async () => {
    await parseOne('DELETE FROM t RETURNING *', pg);
    await parseOne('DELETE FROM t WHERE id = 1 RETURNING id', pg);
  });
});

describe('PostgreSQL - Binary Operators', () => {
  test('parse_pg_binary_ops', async () => {
    await parseOne("SELECT 'hello' || 'world'", pg);
    await parseOne('SELECT a # b', pg);
    await parseOne('SELECT a >> b', pg);
    await parseOne('SELECT a << b', pg);
    await parseOne("SELECT '{1,2}' && '{2,3}'", pg);
    await parseOne("SELECT point '(0,0)' <-> point '(1,1)'", pg);
  });

  test('parse_pg_regex_ops', async () => {
    await parseOne("SELECT 'hello' ~ 'ell'", pg);
    await parseOne("SELECT 'hello' ~* 'ELL'", pg);
    await parseOne("SELECT 'hello' !~ 'ell'", pg);
    await parseOne("SELECT 'hello' !~* 'ELL'", pg);
  });

  test('parse_pg_like_ops', async () => {
    await parseOne("SELECT 'hello' ~~ 'h%'", pg);
    await parseOne("SELECT 'hello' ~~* 'H%'", pg);
    await parseOne("SELECT 'hello' !~~ 'h%'", pg);
    await parseOne("SELECT 'hello' !~~* 'H%'", pg);
  });
});

describe('PostgreSQL - Unary Operators', () => {
  test('parse_pg_unary_ops', async () => {
    await parseOne('SELECT |/ 4', pg);
    await parseOne('SELECT ||/ 27', pg);
    await parseOne('SELECT @ -5', pg);
    await parseOne('SELECT !! 5', pg);
  });

  test('parse_pg_postfix_factorial', async () => {
    await parseOne('SELECT 5!', pg);
  });
});

describe('PostgreSQL - Arrays', () => {
  test('parse_array_literal', async () => {
    await parseOne('SELECT ARRAY[1, 2, 3]', pg);
    await parseOne("SELECT ARRAY['a', 'b', 'c']", pg);
    await parseOne('SELECT ARRAY[[1, 2], [3, 4]]', pg);
  });

  test('parse_array_index', async () => {
    await parseOne('SELECT arr[1]', pg);
    await parseOne('SELECT arr[1][2]', pg);
    await parseOne('SELECT arr[1:3]', pg);
    await parseOne('SELECT arr[1:3][2:4]', pg);
  });

  test('parse_array_subscript', async () => {
    await parseOne('SELECT arr[:]', pg);
    await parseOne('SELECT arr[1:]', pg);
    await parseOne('SELECT arr[:3]', pg);
  });
});

describe('PostgreSQL - CREATE INDEX', () => {
  test('parse_create_index', async () => {
    await parseOne('CREATE INDEX idx ON t (col)', pg);
    await parseOne('CREATE INDEX IF NOT EXISTS idx ON t (col)', pg);
    await parseOne('CREATE UNIQUE INDEX idx ON t (col)', pg);
    await parseOne('CREATE INDEX CONCURRENTLY idx ON t (col)', pg);
  });

  test('parse_create_index_using', async () => {
    await parseOne('CREATE INDEX idx ON t USING btree (col)', pg);
    await parseOne('CREATE INDEX idx ON t USING hash (col)', pg);
    await parseOne('CREATE INDEX idx ON t USING gist (col)', pg);
    await parseOne('CREATE INDEX idx ON t USING gin (col)', pg);
  });

  test('parse_create_index_with_operator_class', async () => {
    await parseOne('CREATE INDEX idx ON t (col text_pattern_ops)', pg);
    await parseOne('CREATE INDEX idx ON t USING gin (col gin_trgm_ops)', pg);
  });

  test('parse_create_index_include', async () => {
    await parseOne('CREATE INDEX idx ON t (col1) INCLUDE (col2, col3)', pg);
  });

  test('parse_create_index_nulls_distinct', async () => {
    await parseOne('CREATE UNIQUE INDEX idx ON t (col) NULLS DISTINCT', pg);
    await parseOne('CREATE UNIQUE INDEX idx ON t (col) NULLS NOT DISTINCT', pg);
  });

  test('parse_create_index_where', async () => {
    await parseOne('CREATE INDEX idx ON t (col) WHERE active = true', pg);
  });
});

describe('PostgreSQL - SCHEMA', () => {
  test('parse_create_schema', async () => {
    await parseOne('CREATE SCHEMA my_schema', pg);
    await parseOne('CREATE SCHEMA IF NOT EXISTS my_schema', pg);
    await parseOne('CREATE SCHEMA my_schema AUTHORIZATION user_name', pg);
    await parseOne('CREATE SCHEMA AUTHORIZATION user_name', pg);
  });

  test('parse_drop_schema', async () => {
    await parseOne('DROP SCHEMA my_schema', pg);
    await parseOne('DROP SCHEMA IF EXISTS my_schema', pg);
    await parseOne('DROP SCHEMA my_schema CASCADE', pg);
  });
});

describe('PostgreSQL - Data Types', () => {
  test('parse_pg_specific_types', async () => {
    await parseOne('CREATE TABLE t (id UUID)', pg);
    await parseOne('CREATE TABLE t (data JSONB)', pg);
    await parseOne('CREATE TABLE t (data JSON)', pg);
    await parseOne('CREATE TABLE t (ip INET)', pg);
    await parseOne('CREATE TABLE t (ip CIDR)', pg);
    await parseOne('CREATE TABLE t (mac MACADDR)', pg);
    await parseOne('CREATE TABLE t (bits BIT(8))', pg);
    await parseOne('CREATE TABLE t (bits VARBIT(8))', pg);
    await parseOne('CREATE TABLE t (data BYTEA)', pg);
  });

  test('parse_pg_range_types', async () => {
    await parseOne('CREATE TABLE t (r INT4RANGE)', pg);
    await parseOne('CREATE TABLE t (r INT8RANGE)', pg);
    await parseOne('CREATE TABLE t (r NUMRANGE)', pg);
    await parseOne('CREATE TABLE t (r TSRANGE)', pg);
    await parseOne('CREATE TABLE t (r TSTZRANGE)', pg);
    await parseOne('CREATE TABLE t (r DATERANGE)', pg);
  });

  test('parse_interval', async () => {
    await parseOne("SELECT INTERVAL '1 day'", pg);
    await parseOne("SELECT INTERVAL '1 year 2 months'", pg);
    await parseOne("SELECT INTERVAL '1' DAY", pg);
    await parseOne("SELECT INTERVAL '1-2' YEAR TO MONTH", pg);
  });
});

describe('PostgreSQL - Type Casts', () => {
  test('parse_double_colon_cast', async () => {
    await parseOne('SELECT 1::INT', pg);
    await parseOne("SELECT '2023-01-01'::DATE", pg);
    await parseOne('SELECT col::VARCHAR(255)', pg);
    await parseOne('SELECT col::INT[]', pg);
    await parseOne("SELECT '1'::INT::TEXT", pg);
  });
});

describe('PostgreSQL - LATERAL', () => {
  test('parse_lateral', async () => {
    await parseOne('SELECT * FROM t1, LATERAL (SELECT * FROM t2 WHERE t2.id = t1.id) AS sub', pg);
    await parseOne('SELECT * FROM t1 CROSS JOIN LATERAL (SELECT * FROM t2 WHERE t2.id = t1.id) AS sub', pg);
  });
});

describe('PostgreSQL - Locking', () => {
  test('parse_for_update', async () => {
    await parseOne('SELECT * FROM t FOR UPDATE', pg);
    await parseOne('SELECT * FROM t FOR UPDATE OF t', pg);
    await parseOne('SELECT * FROM t FOR UPDATE NOWAIT', pg);
    await parseOne('SELECT * FROM t FOR UPDATE SKIP LOCKED', pg);
  });

  test('parse_for_share', async () => {
    await parseOne('SELECT * FROM t FOR SHARE', pg);
    await parseOne('SELECT * FROM t FOR SHARE OF t NOWAIT', pg);
  });
});

describe('PostgreSQL - DISTINCT ON', () => {
  test('parse_distinct_on', async () => {
    await parseOne('SELECT DISTINCT ON (col1) * FROM t', pg);
    await parseOne('SELECT DISTINCT ON (col1, col2) col1, col2, col3 FROM t', pg);
  });
});

describe('PostgreSQL - VACUUM/ANALYZE', () => {
  test.skip('parse_vacuum', async () => {
    // VACUUM is not yet fully supported
    await parseOne('VACUUM', pg);
    await parseOne('VACUUM t', pg);
    await parseOne('VACUUM FULL t', pg);
    await parseOne('VACUUM ANALYZE t', pg);
    await parseOne('VACUUM (VERBOSE) t', pg);
  });

  test.skip('parse_analyze', async () => {
    // ANALYZE standalone is not yet fully supported
    await parseOne('ANALYZE', pg);
    await parseOne('ANALYZE t', pg);
    await parseOne('ANALYZE t (col1, col2)', pg);
  });
});

describe('PostgreSQL - COMMENT', () => {
  test('parse_comment', async () => {
    await parseOne("COMMENT ON TABLE t IS 'This is a table'", pg);
    await parseOne("COMMENT ON COLUMN t.col IS 'This is a column'", pg);
    await parseOne('COMMENT ON TABLE t IS NULL', pg);
  });
});

describe('PostgreSQL - LISTEN/NOTIFY', () => {
  test('parse_listen_notify', async () => {
    await parseOne('LISTEN channel_name', pg);
    await parseOne('NOTIFY channel_name', pg);
    await parseOne("NOTIFY channel_name, 'payload'", pg);
    await parseOne('UNLISTEN channel_name', pg);
    await parseOne('UNLISTEN *', pg);
  });
});

describe('PostgreSQL - Dollar Quoted Strings', () => {
  test('parse_dollar_quoted_strings', async () => {
    await parseOne("SELECT $$hello world$$", pg);
    await parseOne("SELECT $tag$hello world$tag$", pg);
    await parseOne("SELECT $a$can contain ' quotes$a$", pg);
  });
});

describe('PostgreSQL - Error Cases', () => {
  test('parse_bad_if_not_exists', async () => {
    await expectParseError('CREATE TABLE IF EXISTS t (id INT)', pg);
  });
});
