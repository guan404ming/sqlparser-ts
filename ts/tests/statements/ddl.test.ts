/**
 * DDL (Data Definition Language) tests
 * Tests for CREATE, ALTER, DROP statements
 */

import {
  parse,
  parseOne,
  format,
  expectParseError,
  dialects,
  ensureWasmInitialized,
  isCreateTable,
  isCreateView,
  isCreateIndex,
  isAlterTable,
  isDrop,
} from '../test-utils';

beforeAll(async () => {
  await ensureWasmInitialized();
});

describe('CREATE TABLE', () => {
  test('parse basic CREATE TABLE', async () => {
    const stmt = await parseOne('CREATE TABLE t (id INT)');
    expect(isCreateTable(stmt)).toBe(true);
  });

  test('parse CREATE TABLE with multiple columns', async () => {
    await parseOne('CREATE TABLE t (id INT, name VARCHAR(255), created_at TIMESTAMP)');
  });

  test('parse CREATE TABLE IF NOT EXISTS', async () => {
    await parseOne('CREATE TABLE IF NOT EXISTS t (id INT)');
  });

  test('parse CREATE TEMPORARY TABLE', async () => {
    await parseOne('CREATE TEMPORARY TABLE t (id INT)');
    await parseOne('CREATE TEMP TABLE t (id INT)');
  });

  test('parse CREATE OR REPLACE TABLE', async () => {
    await parseOne('CREATE OR REPLACE TABLE t (id INT)', dialects.snowflake);
  });

  describe('Column constraints', () => {
    test('parse NOT NULL', async () => {
      await parseOne('CREATE TABLE t (id INT NOT NULL)');
    });

    test('parse NULL', async () => {
      await parseOne('CREATE TABLE t (id INT NULL)');
    });

    test('parse PRIMARY KEY', async () => {
      await parseOne('CREATE TABLE t (id INT PRIMARY KEY)');
    });

    test('parse UNIQUE', async () => {
      await parseOne('CREATE TABLE t (email VARCHAR(255) UNIQUE)');
    });

    test('parse DEFAULT', async () => {
      await parseOne('CREATE TABLE t (status VARCHAR(10) DEFAULT \'active\')');
      await parseOne('CREATE TABLE t (count INT DEFAULT 0)');
    });

    test('parse CHECK', async () => {
      await parseOne('CREATE TABLE t (age INT CHECK (age >= 0))');
    });

    test('parse REFERENCES', async () => {
      await parseOne('CREATE TABLE t (parent_id INT REFERENCES parent(id))');
    });

    test('parse AUTO_INCREMENT (MySQL)', async () => {
      await parseOne('CREATE TABLE t (id INT AUTO_INCREMENT)', dialects.mysql);
    });

    test('parse IDENTITY (MSSQL)', async () => {
      await parseOne('CREATE TABLE t (id INT IDENTITY)', dialects.mssql);
      await parseOne('CREATE TABLE t (id INT IDENTITY(1, 1))', dialects.mssql);
    });

    test('parse GENERATED (PostgreSQL)', async () => {
      await parseOne('CREATE TABLE t (id INT GENERATED ALWAYS AS IDENTITY)', dialects.postgresql);
      await parseOne('CREATE TABLE t (id INT GENERATED BY DEFAULT AS IDENTITY)', dialects.postgresql);
    });

    test('parse COLLATE', async () => {
      await parseOne('CREATE TABLE t (name VARCHAR(255) COLLATE utf8mb4_unicode_ci)', dialects.mysql);
    });

    test('parse COMMENT (MySQL)', async () => {
      await parseOne("CREATE TABLE t (id INT COMMENT 'primary key')", dialects.mysql);
    });
  });

  describe('Table constraints', () => {
    test('parse PRIMARY KEY constraint', async () => {
      await parseOne('CREATE TABLE t (id INT, PRIMARY KEY (id))');
      await parseOne('CREATE TABLE t (id INT, name VARCHAR(255), PRIMARY KEY (id, name))');
    });

    test('parse UNIQUE constraint', async () => {
      await parseOne('CREATE TABLE t (id INT, UNIQUE (id))');
      await parseOne('CREATE TABLE t (email VARCHAR(255), UNIQUE (email))');
    });

    test('parse FOREIGN KEY constraint', async () => {
      await parseOne('CREATE TABLE t (parent_id INT, FOREIGN KEY (parent_id) REFERENCES parent(id))');
      await parseOne('CREATE TABLE t (id INT, FOREIGN KEY (id) REFERENCES parent(id) ON DELETE CASCADE)');
    });

    test('parse CHECK constraint', async () => {
      await parseOne('CREATE TABLE t (age INT, CHECK (age >= 18))');
    });

    test('parse named constraints', async () => {
      await parseOne('CREATE TABLE t (id INT, CONSTRAINT pk_t PRIMARY KEY (id))');
      await parseOne('CREATE TABLE t (id INT, CONSTRAINT uq_id UNIQUE (id))');
    });
  });

  describe('Data types', () => {
    test('parse integer types', async () => {
      await parseOne('CREATE TABLE t (a TINYINT, b SMALLINT, c INT, d BIGINT)');
    });

    test('parse floating point types', async () => {
      await parseOne('CREATE TABLE t (a FLOAT, b DOUBLE, c DECIMAL(10, 2))');
    });

    test('parse string types', async () => {
      await parseOne('CREATE TABLE t (a CHAR(10), b VARCHAR(255), c TEXT)');
    });

    test('parse date/time types', async () => {
      await parseOne('CREATE TABLE t (a DATE, b TIME, c DATETIME, d TIMESTAMP)');
    });

    test('parse binary types', async () => {
      await parseOne('CREATE TABLE t (a BINARY(16), b VARBINARY(255), c BLOB)');
    });

    test('parse boolean type', async () => {
      await parseOne('CREATE TABLE t (active BOOLEAN)');
    });

    test('parse UUID type', async () => {
      await parseOne('CREATE TABLE t (id UUID)', dialects.postgresql);
    });

    test('parse JSON types', async () => {
      await parseOne('CREATE TABLE t (data JSON)', dialects.mysql);
      await parseOne('CREATE TABLE t (data JSONB)', dialects.postgresql);
    });

    test('parse array types (PostgreSQL)', async () => {
      await parseOne('CREATE TABLE t (tags TEXT[])', dialects.postgresql);
      await parseOne('CREATE TABLE t (matrix INT[][])', dialects.postgresql);
    });
  });

  describe('CREATE TABLE AS SELECT', () => {
    test('parse CREATE TABLE AS', async () => {
      await parseOne('CREATE TABLE t AS SELECT * FROM other');
    });

    test.skip('parse CREATE TABLE AS with columns', async () => {
      // Column list in CREATE TABLE AS not yet fully supported
      await parseOne('CREATE TABLE t (id, name) AS SELECT a, b FROM other');
    });
  });

  describe('Table options', () => {
    test('parse ENGINE (MySQL)', async () => {
      await parseOne('CREATE TABLE t (id INT) ENGINE = InnoDB', dialects.mysql);
    });

    test('parse CHARSET (MySQL)', async () => {
      await parseOne('CREATE TABLE t (id INT) DEFAULT CHARSET = utf8mb4', dialects.mysql);
    });

    test('parse COLLATE (MySQL)', async () => {
      await parseOne('CREATE TABLE t (id INT) COLLATE = utf8mb4_unicode_ci', dialects.mysql);
    });

    test('parse COMMENT (MySQL)', async () => {
      await parseOne("CREATE TABLE t (id INT) COMMENT = 'test table'", dialects.mysql);
    });
  });
});

describe('CREATE VIEW', () => {
  test('parse CREATE VIEW', async () => {
    const stmt = await parseOne('CREATE VIEW v AS SELECT * FROM t');
    expect(isCreateView(stmt)).toBe(true);
  });

  test('parse CREATE VIEW with columns', async () => {
    await parseOne('CREATE VIEW v (a, b) AS SELECT x, y FROM t');
  });

  test('parse CREATE OR REPLACE VIEW', async () => {
    await parseOne('CREATE OR REPLACE VIEW v AS SELECT * FROM t');
  });

  test('parse CREATE MATERIALIZED VIEW', async () => {
    await parseOne('CREATE MATERIALIZED VIEW v AS SELECT * FROM t', dialects.postgresql);
  });

  test('parse CREATE VIEW IF NOT EXISTS', async () => {
    await parseOne('CREATE VIEW IF NOT EXISTS v AS SELECT * FROM t');
  });
});

describe('CREATE INDEX', () => {
  test('parse CREATE INDEX', async () => {
    const stmt = await parseOne('CREATE INDEX idx ON t (col)');
    expect(isCreateIndex(stmt)).toBe(true);
  });

  test('parse CREATE INDEX with multiple columns', async () => {
    await parseOne('CREATE INDEX idx ON t (col1, col2)');
  });

  test('parse CREATE UNIQUE INDEX', async () => {
    await parseOne('CREATE UNIQUE INDEX idx ON t (col)');
  });

  test('parse CREATE INDEX IF NOT EXISTS', async () => {
    await parseOne('CREATE INDEX IF NOT EXISTS idx ON t (col)');
  });

  test('parse CREATE INDEX with USING (PostgreSQL)', async () => {
    await parseOne('CREATE INDEX idx ON t USING btree (col)', dialects.postgresql);
    await parseOne('CREATE INDEX idx ON t USING hash (col)', dialects.postgresql);
  });

  test('parse CREATE INDEX CONCURRENTLY (PostgreSQL)', async () => {
    await parseOne('CREATE INDEX CONCURRENTLY idx ON t (col)', dialects.postgresql);
  });

  test('parse CREATE INDEX with WHERE (PostgreSQL)', async () => {
    await parseOne('CREATE INDEX idx ON t (col) WHERE active = true', dialects.postgresql);
  });
});

describe('ALTER TABLE', () => {
  test('parse ALTER TABLE ADD COLUMN', async () => {
    const stmt = await parseOne('ALTER TABLE t ADD COLUMN new_col INT');
    expect(isAlterTable(stmt)).toBe(true);
  });

  test('parse ALTER TABLE ADD without COLUMN keyword', async () => {
    await parseOne('ALTER TABLE t ADD new_col INT');
  });

  test('parse ALTER TABLE DROP COLUMN', async () => {
    await parseOne('ALTER TABLE t DROP COLUMN old_col');
    await parseOne('ALTER TABLE t DROP old_col');
  });

  test('parse ALTER TABLE RENAME COLUMN', async () => {
    await parseOne('ALTER TABLE t RENAME COLUMN old_name TO new_name');
  });

  test('parse ALTER TABLE RENAME TABLE', async () => {
    await parseOne('ALTER TABLE t RENAME TO new_name');
  });

  test('parse ALTER TABLE ALTER COLUMN', async () => {
    await parseOne('ALTER TABLE t ALTER COLUMN col SET DEFAULT 0');
    await parseOne('ALTER TABLE t ALTER COLUMN col DROP DEFAULT');
    await parseOne('ALTER TABLE t ALTER COLUMN col SET NOT NULL');
    await parseOne('ALTER TABLE t ALTER COLUMN col DROP NOT NULL');
  });

  test('parse ALTER TABLE MODIFY COLUMN (MySQL)', async () => {
    await parseOne('ALTER TABLE t MODIFY COLUMN col VARCHAR(100)', dialects.mysql);
  });

  test('parse ALTER TABLE CHANGE COLUMN (MySQL)', async () => {
    await parseOne('ALTER TABLE t CHANGE COLUMN old_col new_col INT', dialects.mysql);
  });

  test('parse ALTER TABLE ADD CONSTRAINT', async () => {
    await parseOne('ALTER TABLE t ADD CONSTRAINT pk PRIMARY KEY (id)');
    await parseOne('ALTER TABLE t ADD CONSTRAINT fk FOREIGN KEY (parent_id) REFERENCES parent(id)');
  });

  test('parse ALTER TABLE DROP CONSTRAINT', async () => {
    await parseOne('ALTER TABLE t DROP CONSTRAINT constraint_name');
  });

  test('parse ALTER TABLE with IF EXISTS', async () => {
    await parseOne('ALTER TABLE IF EXISTS t ADD COLUMN col INT', dialects.postgresql);
  });
});

describe('DROP statements', () => {
  test('parse DROP TABLE', async () => {
    const stmt = await parseOne('DROP TABLE t');
    expect(isDrop(stmt)).toBe(true);
  });

  test('parse DROP TABLE IF EXISTS', async () => {
    await parseOne('DROP TABLE IF EXISTS t');
  });

  test('parse DROP TABLE multiple tables', async () => {
    await parseOne('DROP TABLE t1, t2, t3');
  });

  test('parse DROP TABLE CASCADE', async () => {
    await parseOne('DROP TABLE t CASCADE', dialects.postgresql);
  });

  test('parse DROP TABLE RESTRICT', async () => {
    await parseOne('DROP TABLE t RESTRICT', dialects.postgresql);
  });

  test('parse DROP VIEW', async () => {
    await parseOne('DROP VIEW v');
    await parseOne('DROP VIEW IF EXISTS v');
  });

  test('parse DROP INDEX', async () => {
    await parseOne('DROP INDEX idx');
    await parseOne('DROP INDEX IF EXISTS idx');
  });

  test('parse DROP SCHEMA', async () => {
    await parseOne('DROP SCHEMA s', dialects.postgresql);
    await parseOne('DROP SCHEMA IF EXISTS s CASCADE', dialects.postgresql);
  });

  test('parse DROP DATABASE', async () => {
    await parseOne('DROP DATABASE db');
    await parseOne('DROP DATABASE IF EXISTS db');
  });
});

describe('CREATE SCHEMA', () => {
  test('parse CREATE SCHEMA', async () => {
    await parseOne('CREATE SCHEMA my_schema', dialects.postgresql);
  });

  test('parse CREATE SCHEMA IF NOT EXISTS', async () => {
    await parseOne('CREATE SCHEMA IF NOT EXISTS my_schema', dialects.postgresql);
  });

  test('parse CREATE SCHEMA AUTHORIZATION', async () => {
    await parseOne('CREATE SCHEMA my_schema AUTHORIZATION user_name', dialects.postgresql);
  });
});

describe('CREATE DATABASE', () => {
  test('parse CREATE DATABASE', async () => {
    await parseOne('CREATE DATABASE mydb');
  });

  test('parse CREATE DATABASE IF NOT EXISTS', async () => {
    await parseOne('CREATE DATABASE IF NOT EXISTS mydb');
  });
});

describe('RENAME', () => {
  test('parse RENAME TABLE (MySQL)', async () => {
    await parseOne('RENAME TABLE old_name TO new_name', dialects.mysql);
  });
});

describe('Complex DDL scenarios', () => {
  test('parse table with all constraint types', async () => {
    await parseOne(`
      CREATE TABLE users (
        id INT PRIMARY KEY,
        email VARCHAR(255) UNIQUE NOT NULL,
        age INT CHECK (age >= 18),
        parent_id INT REFERENCES parent(id),
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);
  });

  test('parse table with composite primary key', async () => {
    await parseOne('CREATE TABLE t (a INT, b INT, PRIMARY KEY (a, b))');
  });

  test('parse table with multiple foreign keys', async () => {
    await parseOne(`
      CREATE TABLE t (
        id INT PRIMARY KEY,
        user_id INT REFERENCES users(id),
        product_id INT REFERENCES products(id)
      )
    `);
  });
});
